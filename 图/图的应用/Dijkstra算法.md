# 前言

由于广度优先搜索总是按照距离由近到远来遍历图中每个顶点，所以广度优先算法并不适合带权图

但需要注意的是Dijkstra算法依然是单源最短路径算法

# 算法思想

## 初始化

`bool final[vertex_num]`

> 表示从源节点到其他节点的最短路径是否已经找到

`int distance[vertex_num]`

> 用来表示从源节点到其余节点的带权路径长度，在算法执行过程中用作参考和修改

`pre_path[vertex_num]`

> 用来表示源节点到其余各个节点的最短路径的前驱顶点

## 算法执行

循环遍历所有产占找到还没确定最短路径，且 `distance[]`最小的顶点$V_i$，令 `final[i] = true`

检查所有邻接自$V_i$的顶,若其 `final[i] = true`，则更新 `distance[]`和 `pre_path[]`信息

## 时间复杂度

一共是$|V|$个顶点，每一轮循环会将找到源节点到一个顶点的最短路径，所以需要$|V|-1$轮循环，时间复杂度为$O(|V|)$

在每一轮循环中，我们需要查找 `distance[]`数组中值最小的顶点，并且还要修改其余节点的 `distance[]`和 `pre_path[]`数组，时间复杂度为$O(2|V|) = O(|V|)$

所以总的时间复杂度为$O(|V|^2)$

# 注意

**结论：Dijkstra算法不适用于有负权值的带权图**
