# 几个前言概念

平衡因子：节点的左子树高-节点的右子树高

**每次调整的都是最小不平衡子树**

这一章学起来真的很有意思

# 平衡二叉树的节点结构

```cpp
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct AVLTreeNode
{
    ElemType data;
    int balance;
    struct BinaryTreeNode* left_child;
    struct BinaryTreeNode* right_child;
} AVLTreeNode, *AVLTree;

```

# 平衡二叉树的插入

> 边插边平衡

## 几个调整形态

- LL：最小不平衡子树的根节点的左孩子的左子树插入节点

> 右旋调整：最小不平衡子树的根节点的左孩子右上旋到最小不平衡子树的根节点位置

- RR：最小不平衡子树的根节点的右孩子的右子树插入节点

> 左旋调整：最小不平衡子树的根节点的右孩子左上旋到最小不平衡子树的根节点位置

- LR：最小不平衡子树的根节点的左孩子的右子树插入节点

> 先左旋，后右旋：最小不平衡子树的根节点的左孩子的右子树的根节点先左上旋，接着将该节点继续右上旋到最小不平衡子树的根节点的位置。共两次上旋操作

- RL：最小不平衡子树的根节点的右孩子的左子树插入节点

> 先右旋，后左旋：最小不平衡子树的根节点的左孩子的右子树的根节点先右上旋，接着将该节点继续左上旋到最小不平衡子树的根节点的位置。共两次上旋操作

## 时间复杂度

假设以$n_h$表示深度为$h$的平衡二叉树中含有的**最少节点数**

则有$n_0=0, n_1=1, n_2 = 2$，并且有递推公式$n_h = n_{h-1} + n_{h-2} + 1$
（可以这么理解，左子树高度为$h-1$，右子树高度为$h-2$）

根据以上公式，可以得出节点数为$n$的平衡二叉树的最大高度为$h_{max} = O(\log_2(n))$

# 平衡二叉树的删除

> 边删边平衡

## 思想

删除节点之后可能导致某一最小子树不平衡，由于树的递归特性，这种不平衡向上传导，最坏情况下这些树都不平衡了，所以全部都要调整

## 具体步骤

1. 删除结点（方法同“二叉排序树”，注意删除的是否是叶子节点，如果是叶子节点，则直接删除，对于非叶子节点，则需要直接前驱节点或直接后继节点进行补充）
2. 一路向北找到最小不平衡子树 ， 找不到就完结撒花
3. 找最小不平衡了树下，“个头”最高的儿子、孙子
4. 根据孙子的位置，调整平衡（LL/RR/LR/RL）
5. 如果不平衡向上传导，继续2这个步骤
   > 改变了某个子树的高度，可能引起上方祖先节点的平衡因子发生变换，进而引起不平衡
   >

## 时间复杂度

平衡二叉树时间复杂度为$O(\log_2 n)$
