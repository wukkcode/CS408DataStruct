# 红黑树的相关概念

## 红黑树的满足条件

0. 红黑树是对二叉排序树的优化，所以它肯定是一棵二叉排序树，满足二叉排序书的要求
1. 每个结点或是红色，或是黑色的
2. 根节点是黑色的
3. 叶结点（外部结点、NULL结点、失败结点）均是黑色的
4. 不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）
5. 对每个结点，**从该节点到任一叶结点**的简单路径上，所含黑结点的数目相同

## 红黑树的性质

黑高bh：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数

性质1：从根节点到叶结点的最长路径不大于最短路径的2倍

> 最长路径，就是红色节点穿插在黑色节点之间，保持路径最长；最短路径就是，整条路径上全是黑色节点

性质2：有n个内部节点的红黑树高度$h≤2\log_2(𝑛+1)$

> 证明：
>
> 设红黑树的高度为 $h$，则红黑树的黑高 $\displaystyle bh \geqslant \frac{h}{2}$
>
> 而黑高为 $bh$ 的红黑树的最少节点数为 $\displaystyle n\geqslant 2^{bh}-1$
>
> 继而得到 $\displaystyle n\geqslant 2^{\frac{h}{2}}-1\Longrightarrow h\leqslant 2\log_2(n+1)$
>
> 保证了红黑树的查找效率为 $O(\log_2n)$

# 红黑树节点结构

```c
typedef int ElemType;
typedef struct RedBlackTreeNode
{
    ElemType key_value;
    struct RedBlackTreeNode* parent;
    struct RedBlackTreeNode* left_child;
    struct RedBlackTreeNode* right_child;
    int node_color;
} RedBlackTreeNode, *RedBlackTree;
```

# 红黑树的查找

红黑树本身还是一个二叉排序树，所以查找操作和二叉排序树一样

# 红黑树的插入

> 边插入，边平衡（重新着色和旋转操作）

## 红黑树插入策略

1. 首先依据二叉排序树的性质，找到要插入的位置
2. 判断插入的位置
   1. 如果是根节点直接将节点染成黑色，则插入结束
   2. 如果是非根节点，则要将节点染成红色，然后观察红黑树的特性（不红红）是否被破坏
      1. 如果没有被破坏，插入结束
      2. 如果被破坏，则需要根据当前插入节点的叔叔节点的颜色进行操作
         1. 如果是其叔叔节点为红色

            > 则将其祖父、父亲、叔叔节点全部换色，然后将祖父节点视作是新插入的节点，看看其是否破坏了红黑树的特性，然后按照规则进行调整
            >
         2. 如果其叔叔节点为黑色

            - LL型：右单旋，父换爷+父节点和爷节点换色
            - RR型：左单旋，父换爷+染色
            - LR型：左、右双旋，儿换爷+染色
            - RL型：右、左双旋，儿换爷+染色

# 红黑树的删除（非常难不是考察重点）

## 考点

- 红黑树删除操作的时间复杂度=$O(\log_2 n)$
- 在红黑树中删除结点的处理方式和“二叉排序树的删除”一样
- 按②删除结点后，可能破坏“红黑树特性”，此时需要调整结点颜色、位置，使其再次满
  足“红黑树特性”。
