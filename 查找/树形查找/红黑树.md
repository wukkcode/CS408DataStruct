# 红黑树的相关概念
## 红黑树的满足条件
0. 红黑树是对二叉排序树的优化，所以它肯定是一棵二叉排序树，满足二叉排序书的要求
1. 每个结点或是红色，或是黑色的
2. 根节点是黑色的
3. 叶结点（外部结点、NULL结点、失败结点）均是黑色的
4. 不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）
5. 对每个结点，**从该节点到任一叶结点**的简单路径上，所含黑结点的数目相同
## 红黑树的性质
黑高bh：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数

性质1：从根节点到叶结点的最长路径不大于最短路径的2倍
> 最长路径，就是红色节点穿插在黑色节点之间，保持路径最长；最短路径就是，整条路径上全是黑色节点
> 
性质2：有n个内部节点的红黑树高度$h≤2\log_2(𝑛+1)$红黑树查找操作时间复杂度=$O(\log_2 𝑛)$
> 证明：一个根节点黑高为$bh$的红黑树，其最少节点数为$2^{bh}-1$。假设一个树的高度为$h$，则根节点的黑高满足$bh >= \frac{h}{2}$，令黑高$bh = \frac{h}{2}$（最小黑高），则一个黑高最少为$\frac{h}{2}$的红黑树的节点总数满足$n >=2^{\frac{h}{2}}-1$，所以可得$h≤2\log_2(𝑛+1)$

> 保证了红黑树的查找效率为$O(\log_2n)$
# 红黑树节点结构
```c
typedef int ElemType;
typedef struct RedBlackTreeNode
{
    ElemType key_value;
    struct RedBlackTreeNode* parent;
    struct RedBlackTreeNode* left_child;
    struct RedBlackTreeNode* right_child;
    int node_color;
} RedBlackTreeNode, *RedBlackTree;
```
# 红黑树的查找
红黑树本身还是一个二叉排序树，所以查找操作和二叉排序树一样
# 红黑树的插入
> 边插入，边平衡（重新着色和旋转操作）

## 红黑树插入策略
1. 首先依据二叉排序树的性质，找到要插入的位置
2. 判断插入的位置
   1. 如果是根节点直接将节点染成黑色，则插入结束
   2. 如果是非根节点，则要将节点染成红色，然后观察红黑树的特性（不红红）是否被破坏
      1. 如果没有被破坏，插入结束
      2. 如果被破坏，则需要根据当前插入节点的叔叔节点的颜色进行操作
         1. 如果是其叔叔节点为红色
            > 则将其祖父、父亲、叔叔节点全部换色，然后将祖父节点视作是新节点，看看其是否破坏了红黑树的特性，然后按照规则进行调整
         3. 如果其叔叔节点为黑色
            - LL型：右单旋，父换爷+染色
            - RR型：左单旋，父换爷+染色
            - LR型：左、右双旋，儿换爷+染色
            - RL型：右、左双旋，儿换爷+染色

# 红黑树的删除（非常难不是考察重点）
## 考点
- 红黑树删除操作的时间复杂度=$O(\log_2 n)$
- 在红黑树中删除结点的处理方式和“二叉排序树的删除”一样
- 按②删除结点后，可能破坏“红黑树特性”，此时需要调整结点颜色、位置，使其再次满
足“红黑树特性”。